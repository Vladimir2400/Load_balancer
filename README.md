# Go Load Balancer with Rate Limiting


*   **HTTP/HTTPS Балансировка нагрузки:** Перенаправляет запросы на настроенные бэкенд-серверы.
*   **Алгоритм Round Robin:** Равномерно распределяет нагрузку между доступными бэкендами.
*   **Проверки состояния (Health Checks):** Периодически проверяет доступность бэкендов по TCP и автоматически исключает недоступные серверы из ротации.
*   **Rate Limiting (Опционально):** Ограничивает частоту запросов от каждого IP-адреса с использованием Token Bucket.
    *   Настраиваемые параметры по умолчанию (емкость бакета, скорость пополнения).
    *   Поддержка кастомных лимитов для отдельных клиентов через базу данных SQLite.
    *   Автоматическая очистка неактивных бакетов для предотвращения утечек памяти.
*   **Конфигурация через YAML:** Основные параметры настраиваются через файл `config.yaml`.
*   **Graceful Shutdown:** Корректно завершает работу при получении сигналов SIGINT или SIGTERM, дожидаясь завершения активных запросов.
*   **Модульная структура:** Код разделен на логические пакеты (`balancer`, `config`, `ratelimiter`, `middleware`, `storage`).

## Требования

*   Go 1.18 или выше
*   GCC или совместимый C компилятор (требуется для `go-sqlite3` CGO)

## Конфигурация (`config.yaml`)

Файл конфигурации по умолчанию - config.yaml. **При первом запуске или после клонирования репозитория скопируйте config.yaml.example в config.yaml и отредактируйте его под ваше окружение.** Путь к используемому файлу config.yaml можно изменить с помощью флага -config.

Пример `config.yaml.example`:

```yaml
# Порт, на котором будет работать балансировщик
port: ":8080"

# Список URL бэкенд-серверов
backends:
  - "http://localhost:8081"
  - "http://localhost:8082"
  - "http://localhost:8083"
  # - "https://example.com:443" # Можно использовать HTTPS

# Параметры проверки состояния бэкендов
health_check_interval: "15s" # Как часто проверять (формат time.Duration)
health_check_timeout: "3s"   # Таймаут для одной проверки

# Настройки Rate Limiter
rate_limiter:
  enabled: true                 # Включить Rate Limiter? (true/false)
  default_capacity: 20          # Емкость бакета по умолчанию
  default_refill_rate: 5        # Скорость пополнения по умолчанию (токенов/сек)
  cleanup_interval: "10m"       # Как часто удалять неактивные бакеты
  # Настройки БД для кастомных лимитов (опционально)
  db:
    driver: "sqlite"            # Драйвер (пока только "sqlite")
    path: "./limits.db"         # Путь к файлу SQLite БД
```

**Переменные окружения:**

*   `LB_LISTEN_ADDR`: Позволяет переопределить значение `port` из конфигурации.

## Сборка

Для сборки приложения перейдите в директорию `cloud/load_balancer` и выполните:

```bash
# Загрузка зависимостей (включая CGO для SQLite)
go mod tidy

# Сборка бинарного файла 'lb'
go build -o lb ./cmd/server
```

## Запуск

 1.**Создайте файл конфигурации:**
    ```bash
    # В Linux/macOS:
    cp config.yaml.example config.yaml
    # В Windows (Command Prompt):
    # copy config.yaml.example config.yaml
    # В Windows (PowerShell):
    # Copy-Item config.yaml.example config.yaml
    ```
2.  **Отредактируйте `config.yaml`:** Укажите правильные URL ваших бэкенд-серверов и другие     параметры.
3.  **Запустите балансировщик:**
    ```bash
    # В Linux/macOS:
    ./lb

    # В Windows:
    # .\lb.ex
    # Запуск с другим файлом конфигурации (пример для Linux/macOS):
    # ./lb --config=/path/to/your/config.yaml
    ```

    Балансировщик начнет слушать порт, указанный в конфигурации, и логировать свою работу в консоль. Для остановки нажмите `Ctrl+C`.

## Тестирование

Для запуска юнит-тестов и проверки на состояние гонки (race detector) выполните:

```bash
go test ./... -race
```

## Rate Limiting

Когда `rate_limiter.enabled` установлено в `true`:

1.  Каждый уникальный IP-адрес получает свой "бакет токенов".
2.  При первом запросе бакет создается с `default_capacity`.
3.  Бакет пополняется со скоростью `default_refill_rate` токенов в секунду.
4.  Каждый запрос от IP "потребляет" один токен.
5.  Если в бакете нет токенов, запрос отклоняется с кодом `429 Too Many Requests`.
6.  **Кастомные лимиты:** Если настроена база данных SQLite (`rate_limiter.db`), балансировщик будет искать лимиты для IP в таблице `client_limits`. Если запись найдена, используются значения `capacity` и `rate` из БД вместо дефолтных.
7.  **Очистка:** Каждые `cleanup_interval` происходит удаление бакетов, к которым не было обращений дольше, чем `cleanup_interval * 2`.

## Admin API (Управление лимитами)

Если в конфигурации включен `rate_limiter` и настроена база данных (например, SQLite), становится доступным Admin API для управления кастомными лимитами клиентов.

**Базовый путь:** `/admin/limits`

**Эндпоинты:**

*   **`POST /admin/limits`**
    *   Назначение: Устанавливает или обновляет кастомные лимиты для клиента.
    *   Тело запроса (JSON):
        ```json
        {
          "client_id": "<идентификатор_клиента>",
          "capacity": <целое_число_емкость>,
          "rate": <число_скорость_пополнения_в_сек>
        }
        ```
    *   Ответы:
        *   `200 OK`: Лимит успешно установлен/обновлен. Тело ответа содержит установленные лимиты.
        *   `400 Bad Request`: Невалидное тело запроса или параметры (например, отрицательная емкость).
        *   `500 Internal Server Error`: Ошибка при сохранении в БД.
        *   `501 Not Implemented`: Admin API отключен (БД не настроена).

*   **`GET /admin/limits/{client_id}`**
    *   Назначение: Получает текущие кастомные лимиты для указанного клиента.
    *   Параметр пути: `{client_id}` - идентификатор клиента (например, IP-адрес).
    *   Ответы:
        *   `200 OK`: Тело ответа содержит лимиты клиента в формате JSON (`{"client_id": "...", "capacity": ..., "rate": ...}`).
        *   `404 Not Found`: Кастомный лимит для данного клиента не найден (будут использоваться лимиты по умолчанию).
        *   `500 Internal Server Error`: Ошибка при чтении из БД.
        *   `501 Not Implemented`: Admin API отключен.

*   **`DELETE /admin/limits/{client_id}`**
    *   Назначение: Удаляет кастомные лимиты для указанного клиента. После удаления для клиента будут использоваться лимиты по умолчанию.
    *   Параметр пути: `{client_id}` - идентификатор клиента.
    *   Ответы:
        *   `204 No Content`: Лимит успешно удален (или не существовал).
        *   `500 Internal Server Error`: Ошибка при удалении из БД.
        *   `501 Not Implemented`: Admin API отключен.

**Пример использования `curl`:**

```bash
  # Добавить лимит (ожидаем 200 OK с JSON)
        curl -X POST -H "Content-Type: application/json" -d '{"client_id":"1.2.3.4", "capacity":10, "rate":1}' http://localhost:8080/admin/limits

        # Получить лимит (ожидаем 200 OK с JSON)
        curl http://localhost:8080/admin/limits/1.2.3.4

        # Попробовать превысить лимит (ожидаем несколько 200 OK от бэкенда, затем 429 JSON)
        for i in {1..15}; do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:8080/ -A "Client1.2.3.4"; done 
        # (В Windows/PowerShell цикл for может выглядеть иначе, или можно просто запустить curl много раз вручную)
        # Пример для PowerShell: 1..15 | % { curl -s -o NUL -w "%{http_code}`n" http://localhost:8080/ -UserAgent "Client1.2.3.4" }

        # Удалить лимит (ожидаем 204 No Content)
        curl -X DELETE http://localhost:8080/admin/limits/1.2.3.4

        # Получить лимит снова (ожидаем 404 JSON)
        curl -i http://localhost:8080/admin/limits/1.2.3.4 

        # Проверить ошибку 503 JSON, если остановить все бэкенды и послать запрос на /
        # curl http://localhost:8080/
